// \phi : \u03D5
// \delta : \u03B4
// \in : \u2208
// \squsubset : \u228F
// \iff : \u21D4

package at.forsyte.apalache.tla.lir

import scala.collection.immutable.{HashMap, Map, Set}
import java.io._

import com.microsoft.z3._
import at.forsyte.apalache.tla.lir.actions.TlaActionOper
import at.forsyte.apalache.tla.lir.oper.{TlaBoolOper, TlaSetOper}
import at.forsyte.apalache.tla.lir.plugins.UniqueDB

package object assignments{

  /**
    * Symbols to be used for variable, resp. function, names in SMT.
    */
  protected var m_varSym = "A"
  protected var m_fnSym = "R"

  /**
    * Should be immutable, since the names a re arbitrary anyway.
    * Otherwise, there could be problems with names changing mid-execution.
    */
  //  def varSym : String = m_varSym
  //  def varSym_=( p_sym : String ) : Unit = {
  //    m_varSym = p_sym
  //  }
  //
  //  def fnSym : String = m_fnSym
  //  def fnSym_=( p_sym : String ) : Unit = {
  //    m_fnSym = p_sym
  //  }

  /**
    * Intermediate class for internal use. Represents \u03D5 formulas as trees.
    */
  protected abstract class BoolFormula
  protected case class False() extends BoolFormula
  protected case class And( args : BoolFormula* ) extends BoolFormula
  protected case class Or( args : BoolFormula* ) extends BoolFormula
  protected case class Neg( arg : BoolFormula ) extends BoolFormula
  protected case class Implies( LHS : BoolFormula, RHS : BoolFormula ) extends BoolFormula
  protected case class Variable( id: Int ) extends BoolFormula
  protected case class LtFns( i: Int, j: Int )  extends BoolFormula // ( R( i ) < R( j ) )
  protected case class NeFns( i: Int, j: Int )  extends BoolFormula // ( R( i ) != R( j ) )


  /**
    * Transforms BoolFormula expressions into valid .smt2 format queries recursively.
    * @param phi - The formula being transformed.
    * @return - SMTLIBv2 representation of phi. Does not include top-level assertion command.
    */
  protected def toSmt2( phi : BoolFormula ) : String = {
    phi match{
      case False() => "false" //"( false )"
      case And( args@_* ) => "( and %s )".format( args.map( toSmt2 ).mkString(" ") )
      case Or( args@_* ) => "( or %s )".format( args.map( toSmt2 ).mkString(" ") )
      case Neg( arg : BoolFormula ) => "( not %s )".format( toSmt2( arg ) )
      case Implies( lhs, rhs ) => "( => %s %s )".format( toSmt2( lhs ), toSmt2( rhs ) )
      case Variable( id: Int ) => m_varSym + "_" + id //"( %s_%s )".format( varSym, id )
      case LtFns( i: Int, j: Int ) => "( < ( %s %s ) ( %s %s ) )".format( m_fnSym, i, m_fnSym, j )
      case NeFns( i: Int, j: Int ) => "( not ( = ( %s %s ) ( %s %s ) ) )".format( m_fnSym, i, m_fnSym, j )
    }
  }

  /**
    * Removes spurious branches from the BoolFormula tree to obtain a
    * logically equivalent but smaller formula.
    *
    * Assumes input formulas are generated by the [[delta]] function or equivalent.
    * @see [[delta]]
    * @param phi The formula being transformed.
    * @return A new BoolFormula, logically equivalent to `phi`, with simpler structure.
    */
  protected def simplify( phi: BoolFormula ) : BoolFormula = {
    phi match {
      /**
        * Recursively simplify branches first.
        * If any branch is false, the whole formula is false.
        * It is important to recurse first,
        * since otherwise false-simplification would not propagate upward.
        */
      case And( args@_*) => {
        val newargs = args.map(simplify)
        if ( newargs.contains( False() ) )
          False()
        else
          And( newargs:_* )
      }
      /**
        * Recursively simplify, then drop all False() branches.
        * Afterwards, if the new tree has too few branches prune accordingly.
        */
      case Or( args@_*) => {
        val newargs = args.map(simplify).filterNot( _ == False() )
        newargs.size match {
          case 0 => False()
          case 1 => newargs.head
          case _ =>Or( newargs:_* )
        }
      }
      case _ => phi
    }
  }

  /**
    * Constructs the \u03B4,,v,,(\u03D5) formulas.
    * @param v Variable deciding leaf terms.
    * @param phi Formula being transformed.
    * @return Transformed formula
    * @deprecated
    */
  protected def delta( v: NameEx )( phi: OperEx ) : BoolFormula = {
    // assume well-formedndess, i.e. only and/or/in
    phi.oper match {
      case TlaBoolOper.and => Or( phi.args.map( arg => delta(v)( arg.asInstanceOf[OperEx] ) ):_* )
      case TlaBoolOper.or => And( phi.args.map( arg => delta(v)( arg.asInstanceOf[OperEx] ) ):_* )
      case TlaSetOper.in => {
        phi.args.head match {
          case OperEx( TlaActionOper.prime, NameEx( name ) ) => {
            if( v == NameEx( name ) )
              Variable( phi.ID.id )
            else
              False()
          }
          case _ => False()
        }
      }
      case _ => False()
    }
  }

  /**
    * Finds the LHS primed variable of a well-formed formula (given by the ID).
    *
    * Well-formed means that the left hand side is a single primed variable.
    * Undefined behaviour if the formula is not well-formed or if the ID is invalid.
    * @param i UID of the formula, assumed to be valid.
    * @return A TLA expression with the name of the variable, unprimed.
    * @see [[rvars]]
    */
  protected def lvar( i : Int ) : NameEx = UniqueDB.apply( UID( i ) ).
    head.asInstanceOf[OperEx].args.
    head.asInstanceOf[OperEx].args.
    head.asInstanceOf[NameEx]

  /**
    * Extracts all primed subexpressions within a given expression, regardless of nesting depth.
    * @param ex An arbitrary TLA expression.
    * @return A set of unprimed names. Each name appears uniquely, regardless of
    *         multiple occurrences with different UIDs.
    */
  protected def findPrimes( ex : TlaEx ) : Set[NameEx] = {
    ex match {
      case OperEx( TlaActionOper.prime, NameEx(n) ) => Set(NameEx(n))
      case OperEx( _, args@_* ) => args.map( findPrimes ).fold( Set[NameEx]() ){ (a,b) => a ++ b }
      case _ => Set[NameEx]()
    }
  }

  /**
    * Finds the RHS primed variables of an arbitrary formula (given by the ID). The RHS
    * does not need to be well-formed.
    *
    * Undefined behaviour if the ID is invalid.
    * @param i UID of the formula, assumed to be valid.
    * @return A set of expressions with the names of the variables, unprimed.
    * @see [[lvar]]
    */
  protected def rvars( i : Int ) : Set[NameEx] = {
    findPrimes(
      UniqueDB(UID(i)).head.asInstanceOf[OperEx].args.tail.head // 2nd arg is the RHS
    )
  }

  /**
    * The \u228F relation.
    *
    * i \u228F j \u21D4 [[lvar]]( i ) \u2208 [[rvars]]( j ).
    * @param i - UID of the first set
    * @param j - UID of the second set
    * @return true iff the relation is satisfied
    */
  protected def sqsubset( i: Int, j: Int ): Boolean = rvars( j ) contains lvar( i )

  /**
    * Main method. Extracts all relevant information in a single pass.
    * We assume the input is preprocessed, all terms that are not of the form a' \u2208 B
    * are ignored for assignment (that icludes all a' = B terms).
    * @param p_phi - Formula to be processed.
    * @param p_vars - Set of all variable names relevant to the spec.
    * @return Returns a triple ( seen, D, deltas ) where seen is the set of all
    *         leaf IDs, D is the set of dependent indices and deltas is a map storing
    *         \u03B4,,v,,(\u03D5) for every v.
    */
  protected def massProcess( p_phi : TlaEx, p_vars: Set[NameEx] )
    : ( Set[Int], Set[(Int,Int)], Map[NameEx,BoolFormula] ) = {
    val ret = innerMassProcess(p_phi,p_vars)
    (ret._1, ret._2, ret._4.map( pa => (pa._1, simplify(pa._2) ) ) )
  }

  /**
    * Recursive submethod called within [[massProcess]].
    * @see [[massProcess]]
    * @return Returns an additional extra set of independent indices, as bookkeeping,
    *         which is discarded in the return of [[massProcess]].
    */
  protected def innerMassProcess( p_phi : TlaEx, p_vars: Set[NameEx] )
                : ( Set[Int], Set[(Int,Int)], Set[(Int,Int)], Map[NameEx,BoolFormula] ) = {

    /** We name the default arguments to return at irrelevant terms  */
    val defaultMap = ( for {v <- p_vars} yield (v, False()) ).toMap
    val defaultArgs = ( Set[Int](), Set[(Int,Int)](), Set[(Int,Int)](), defaultMap )

    p_phi match {
      /**
        * The delta_v function is defined only on boolean conjunctions/disjunctions
        * and leafs ( \u2208 expressions ). At a leaf with id i, if [[lvar]](i) is v
        * the delta formula evaluates to a fresh boolean variable A_i. Otherwise, we compute the
        * deltas for all branches and flip the boolean connective.
        *
        * The (in)dependece sets are directly computable at leafs, for a leaf with id i
        * the dep. set D is {(i,i)} and the indep. set I is {}.
        * Otherwise, at a boolean connective, we first compute all (D_j,I_j) pairs for all children
        * and the set S' of all seen ids so far. To obtain (D_i,I_i) at the call level, recall that
        * D_i \cup I_i = S' \times S' = S, as each pair is either dependent of independent.
        * Let D_i' be the union of all D_j, similarly for I_i'. We need to determine whether
        * all elements of U = S \ ( D_i' \cup I_i') should belong to D_i or I_i.
        * If the connective is AND, then the first common ancestor of all pairs in U is this AND
        * node and therefore all pairs in U are dependent, since any branch will include all
        * subbranches of an AND node. Then, D_i = S \ I_i' and I_i = I_i'.
        * Conversely, if the node is an OR, D_i = D_i' and I_i = S \ D_i'.
        *
        * The set of seen elements is simply the union of all such child sets.
        *
        */
      case OperEx(oper, args@_*) =>
        oper match{
          /** Recursive case */
          case TlaBoolOper.and | TlaBoolOper.or =>
            /** First, process all children */
            val processedArgs : Seq[ ( Set[Int],
                                       Set[(Int,Int)],
                                       Set[(Int,Int)],
                                       Map[NameEx,BoolFormula] ) ]
                = args.map( innerMassProcess( _, p_vars) )

            /** Next, compute a map from each v to a sequence of all child delta_v formulas  */
            val newMapArgs : Map[ NameEx, Seq[BoolFormula] ] =
              ( for { v <- p_vars } yield
                ( v,
                  processedArgs.map(
                    tpl => tpl._4 // Take the deltas map
                  ).map(
                    _.get(v) // Take the current delta_v
                  ).map(
                    _.head // We know none of them are None by construction
                  )
                )
              ).toMap

            /* Old: used to include filterNot( _.isEmpty )

            processedArgs.map(
              tpl => tpl._4
            ).map(
              _.get(v)
            ).filterNot(
              _.isEmpty
            ).map(
              _.head
            )
            */

            /**
              * The rest we obtain by folding and taking the unions of all components.
              * The default arguments are empty sets as not to impact the result.
              */
            val ( seen, depSet, indepSet, _ ) = processedArgs.fold(
              defaultArgs
            ){
              ( a,b ) => ( a._1 ++ b._1,
                           a._2 ++ b._2,
                           a._3 ++ b._3,
                           defaultArgs._4 // irrelevant
              )
            }

            /** Deltas flip boolean connectives */
            val newMap : Map[NameEx,BoolFormula] =
              (
                for { v <- p_vars }
                  yield ( v,
                          if (oper == TlaBoolOper.and)
                            Or(newMapArgs(v):_*)
                          else
                            And(newMapArgs(v):_*)
                        )
              ).toMap

            /** S is the set of all index pairs which we will be certain about after this step */
            val S : Set[(Int,Int)] = for { x <- seen; y <- seen } yield (x,y)

            /** One set is unchanged, the other is the remeining elements from S */
            oper match {
              case TlaBoolOper.and => ( seen, S -- indepSet, indepSet, newMap )
              case TlaBoolOper.or  => ( seen, depSet, S -- depSet, newMap )
            }
          /** Base case */
          case TlaSetOper.in =>
            /** First, we check for well-formed expr., i.e. a' \in B */
            args.head match {
              case OperEx( TlaActionOper.prime, nameEx ) =>
                val n : Int = p_phi.ID.id
                /** Use the definition of delta_v for base cases */
                val newmap =
                  ( for { v <- p_vars }
                      yield ( v,
                              if( nameEx == v )
                                Variable( n )
                              else
                                False()
                            )
                  ).toMap
                /** If well formed, S = {n}, D = {(n,n)}, I = {}, deltas = newmap */
                /* return */ ( Set[Int](n), Set[(Int,Int)]( (n,n) ), Set[(Int,Int)](), newmap )
              case _ =>
                /** If not well-formed, ignore and return empty sets/trivial maps */
                /* return */ defaultArgs
            }
          /** Other case */
          case _ =>
            /** If the term is of any other form it is just ignored */
            /* return */ defaultArgs
        }
      /** Not an operator. We know the top-level call is on an OperEx. Other terms are ignored */
      case _ => defaultArgs
    }
  }

  /**
    * \u03D5
    *
    * Given a Next formula and a set of variables, produces an SMT formula that
    * is satisfiable iff the assignment problem for the given formula has a solution.
    * @param p_vars - The set of variables declared by the specification.
    * @param p_phi - The Next formula.
    * @param p_fileName - Optional parameter, if string is nonempty a file with the
    *                   complete specification is produced, including set-logic,
    *                   check-sat and get-model commands. Set to empty by default.
    * @param p_completeSpec - Optional parameter, if true produces a complete .smt2
    *                       specification, with set-logic, check-sat and get-model commands.
    *                       If false, will only produce the assertions and declarations.
    *                       Set to false by default.
    * @return An SMTLIBv2 string to be used alone or passed to the z3 API. Contains at least all
    *         relevant declarations and assertions.
    */
  def makeSpec( p_vars: Set[NameEx],
                p_phi : OperEx,
                p_fileName : String = "",
                p_completeSpec : Boolean = false
              ) : String = {

    /** Extract the list of leaf ids, the dependency set and the delta mapping */
    val ( seen, deps, deltas ) = massProcess(p_phi, p_vars)

    /** Simplify deltas */
    val simpleDeltas = ( for {v <- p_vars} yield ( v, simplify( deltas(v) ) ) ).toMap

    /**
      * We need two subsets of deps, one where the \sqsubset relation holds
      * and one where lvars match for constructing \phi_R and \phi^\exists!^
      * respectively.
      */
    val D_sqss = deps.filter( pa =>  sqsubset( pa._1, pa._2 ) )
    val D_exOne = deps.filter( pa => pa._1 < pa._2 && lvar( pa._1 ) == lvar( pa._2) )

    /** \phi,,A,, */
    val aargs = simpleDeltas.values
    val aargsSMT = aargs.map( toSmt2 )

    /** \phi,,R,, */
    val rargs =
      for { (i,j) <- D_sqss }
      yield
        Implies(
          And( Variable( i ),
               Variable( j )
          ),
          LtFns( i, j )
        )
    val rargsSMT = rargs.map( toSmt2 )

    /** \phi,,R,,^{\inj}^ */
    val injargs = for { i <- seen; j <- seen if i < j} yield NeFns(i, j)
    val injargsSMT = injargs.map( toSmt2 )
    val exOneargs =
      for { (i,j) <- D_exOne }
        yield Neg( And( Variable( i ), Variable( j ) ) )
    val exOneargsSMT = exOneargs.map( toSmt2 )

    val typedecls = seen.map( "( declare-fun %s_%s () Bool )".format( m_varSym, _ ) ).mkString("\n")
    val fndecls = "\n( declare-fun %s ( Int ) Int )\n".format( m_fnSym)
    val constraints = ( aargsSMT ++ rargsSMT ++ injargsSMT ++ exOneargsSMT ).toSeq.map(
      str => "( assert %s )".format( str )
    ).mkString("\n")

    val ret = typedecls + fndecls + constraints

    val logic = "( set-logic QF_UFLIA )\n"
    val end = "\n( check-sat )\n( get-model )\n( exit )"

    if( p_fileName.nonEmpty ) {

      val pw = new PrintWriter(new File( p_fileName ) )
      pw.write(logic + ret + end)
      pw.close()

    }

    if( p_completeSpec ){
      logic + ret + end
    }
    else{
      ret
    }

  }

  protected class FunWrapper( f: FuncInterp ) {
    protected val m_default : Int = f.getElse.asInstanceOf[IntNum].getInt

    protected val m_map : Map[String, Int] =
      ( for { e: FuncInterp.Entry <- f.getEntries }
          yield (
                  "%s_%s".format(m_varSym,e.getArgs.head ),
                  e.getValue.asInstanceOf[IntNum].getInt
                )
      ).toMap

    def apply( arg: String ): Int = m_map.getOrElse( arg, m_default )

    override def toString: String = m_map.toString

//
//    val temp = m_args.map( x=> x. )

  }

  def getOrder( p_spec : String ) : Option[Seq[(UID,Boolean)]] = {
    val ctx = new Context()
    val s = ctx.mkSolver()
    s.add( ctx.parseSMTLIB2String( p_spec, null, null, null, null ) )

    val status = s.check.toString

    if( status != "SATISFIABLE" )
      return None

    val m = s.getModel

    val fnDecl = m.getFuncDecls

    if( fnDecl.size != 1 )
      return None

    val fnInterp = m.getFuncInterp( fnDecl(0) )

    val wrap = new FunWrapper( fnInterp )

    val varInterps = m.getConstDecls.map( x => ( m.getConstInterp( x ), x.getName.toString ) )

    val sorted = varInterps.sortBy(  x => wrap( x._2 ) )
//    ranks.foreach( println )

    val ret = sorted.map(
        x => (
          UID( x._2.substring(2).toInt ),
          x._1.getBoolValue.toInt == 1 // WHY is there no .toBool????
        )
      )

    return Some( ret )
  }

  def getOrder( p_vars: Set[NameEx],
                p_phi : OperEx,
                p_fileName : String
              ) : Option[Seq[(UID,Boolean)]] = {
    val spec = makeSpec(p_vars,p_phi,p_fileName)
    getOrder( spec )
  }

}


