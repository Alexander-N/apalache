package at.forsyte.apalache.tla.parser

import at.forsyte.apalache.tla.ir._

/**
 * A parser of TLA+ code from XML generated by XMLExporter.
 *
 * @see tla2sany.XMLExporter
 *
 * @todo do a preliminary structure check with XML schema?
 *
 * @author konnov
 */
class XmlImporter {
  var contextToParse: Map[Int, xml.Node] = Map()
  var context: Map[Int, BaseEntry] = Map()

  /**
   * Parse an XML tree created by SANY
   * @param node root node (tagged with modules)
   * @return an internal representation of the TLA spec
   */
  def parse(node: xml.Node): Spec = {
    if (node.label != "modules")
    throw new XmlImporterException(String.format("Expected <modules>...</modules>, found <%s></%s>",
      node.label, node.label))

    contextToParse = collectContextNodes(node \ "context" \ "entry")
    context = Map()
    new Spec((node \ "ModuleNode").map(parseModule).toList)
  }

  private def collectContextNodes(nodes: xml.NodeSeq): Map[Int, xml.Node] = {
    def getUid(node: xml.Node): Int =
      (node \ "UID").text.toInt

    // pick any Elem (not Text!) different from UID
    def getSub(node: xml.Node): xml.Node = {
      val sub = (node \ "_").filter(_.label != "UID")
      if (sub.length == 1)
        sub.head
      else
        throw new XmlImporterException("Unexpected entry structure: " + node.toString())
    }

    nodes.foldLeft (Map[Int, xml.Node]()) ((m, n) => m + (getUid(n) -> getSub(n)))
  }

  private def parseModule(node: xml.Node): Module = {
    val uniqueName = (node \ "uniquename").text
    val origin = parseOrigin(0, (node \ "location").head)
    val vars = (node \ "variables" \ "OpDeclNodeRef" \ "UID").map(parseOpDecl(Kind.Var, _)).toList
    new Module(origin, uniqueName, consts = List(), vars = vars,
      ops = List(), assumptions = List(), theorems = List())
  }

  private def parseOpDecl(kind: Kind.Value, uidNode: xml.Node): UserOpDecl = {
    val uid = uidNode.text.toInt
    if (context.contains(uid))
      context.get(uid).asInstanceOf[UserOpDecl]
    else {
      val node = contextToParse(uid)
      val uniqueName = (node \ "uniquename").text
      val level = (node \ "level").text.toInt
      val origin = parseOrigin(level, (node \ "location").head)
      val arity = (node \ "arity").text.toInt
      val kindId = (node \ "kind").text.toInt
      if (Kind(kindId) != kind)
        throw new XmlImporterException(String.format("Expected kind %s, found %s", Kind(kindId), kind))

      val decl = new UserOpDecl(uid = uid, uniqueName = uniqueName,
        origin = Some(origin), arity = arity, kind = kind)
      context = context + (uid -> decl)
      decl
    }
  }

  private def parseOrigin(level: Int, node: xml.Node): Origin = {
    val filename = (node \ "filename").text
    val startCol = (node \ "column" \ "begin").text.toInt
    val endCol = (node \ "column" \ "end").text.toInt
    val startLine = (node \ "line" \ "begin").text.toInt
    val endLine = (node \ "line" \ "end").text.toInt
    new Origin(level, filename, LocRange(Loc(startLine, startCol), Loc(endLine, endCol)))
  }
}
