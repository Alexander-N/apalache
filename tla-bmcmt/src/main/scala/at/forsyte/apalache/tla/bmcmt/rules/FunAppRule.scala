package at.forsyte.apalache.tla.bmcmt.rules

import at.forsyte.apalache.tla.bmcmt._
import at.forsyte.apalache.tla.bmcmt.implicitConversions._
import at.forsyte.apalache.tla.bmcmt.types._
import at.forsyte.apalache.tla.lir.convenience._
import at.forsyte.apalache.tla.lir.oper.TlaFunOper
import at.forsyte.apalache.tla.lir.{OperEx, TlaEx}

/**
  * Implements the rules: SE-FUN-APP[1-3].
  *
  * @author Igor Konnov
  */
class FunAppRule(rewriter: SymbStateRewriter) extends RewritingRule {
  override def isApplicable(symbState: SymbState): Boolean = {
    symbState.ex match {
      case OperEx(TlaFunOper.app, _*) => true
      case _ => false
    }
  }

  override def apply(state: SymbState): SymbState = {
    state.ex match {
      case OperEx(TlaFunOper.app, funEx, argEx) =>
        // SE-FUN-APP1
        val funState = rewriter.rewriteUntilDone(state.setTheory(CellTheory()).setRex(funEx))
        // SE-FUN-APP2
        val argState = rewriter.rewriteUntilDone(funState.setTheory(CellTheory()).setRex(argEx))
        val funCell = argState.arena.findCellByNameEx(funState.ex)
        val argCell = argState.arena.findCellByNameEx(argState.ex)
        val domainCell = argState.arena.getDom(funCell)
        val codomainCell = argState.arena.getCdm(funCell)

        val resState = codomainCell.cellType match {
          case FinSetT(ConstT()) =>
            pickBasic(ConstT(), codomainCell, argState)

          case FinSetT(IntT()) =>
            pickBasic(IntT(), codomainCell, argState)

          case FinSetT(BoolT()) =>
            pickBasic(BoolT(), codomainCell, argState)

          case FinSetT(t@FinSetT(_)) =>
            pickSet(t, codomainCell, argState)

          case FinSetT(t@FunT(FinSetT(argt), rest)) =>
            pickFun(t, codomainCell, argState)

          case _ =>
            throw new RewriterException("Cannot pick an element from a set of type: " + codomainCell.cellType)
        }
        // SE-FUN-APP3
        val resultCell = resState.ex
        val domCells = resState.arena.getHas(domainCell)

        // cache equalities
        val eqState = rewriter.lazyEquality.cacheEqualities(resState, domCells.map(e => (e, argCell)))

        // Equation (2): there is a domain element that equals to the argument
        def mkInCase(domElem: ArenaCell): TlaEx = {
          val inDomain = tla.in(domElem, domainCell)
          val funEqResult =
            tla.eql(resultCell, tla.appFun(funCell, domElem)) // translated as function application in SMT
          val eq = tla.eql(domElem, argCell) // just use SMT equality, thanks to the constraints generated with lazy equality
          tla.and(inDomain, eq, funEqResult)
        }

        // Equation (3): there is no domain element that equals to the argument
        def mkNotInCase(domElem: ArenaCell): TlaEx = {
          val notInDomain = tla.not(tla.in(domElem, domainCell))
          val eq = tla.eql(domElem, argCell) // just use SMT equality, thanks to the constraints generated with lazy equality
          tla.or(notInDomain, tla.not(eq))
        }

        val found = tla.or(domCells.map(mkInCase): _*)
        val eqFailure = tla.eql(resultCell, eqState.arena.cellFailure())
        val notFound = tla.and(eqFailure, tla.and(domCells.map(mkNotInCase): _*))
        eqState.arena.solverContext.assertGroundExpr(tla.or(found, notFound))

        val finalState = eqState
          .setTheory(CellTheory())
          .setRex(resultCell)
        rewriter.coerce(finalState, state.theory)

      case _ =>
        throw new RewriterException("FunAppRule is not applicable")
    }
  }

  private def pickBasic(cellType: CellT, set: ArenaCell, state: SymbState): SymbState = {
    val newArena = state.arena.appendCell(cellType)
    val resultCell = newArena.topCell
    val setCells = newArena.getHas(set)
    val eqState = rewriter.lazyEquality.cacheEqualities(state, setCells.map(e => (e, resultCell)))

    // the new element equals to an existing element in the set
    def mkIn(domElem: ArenaCell): TlaEx = {
      val inSet = tla.in(domElem, set)
      tla.and(inSet, tla.eql(domElem, resultCell)) // equality constraints are generated by lazy equality
    }

    val found = tla.or(setCells.map(mkIn): _*)
    val cons = decorateWithFailure(found, set, setCells, resultCell, newArena.cellFailure())
    eqState.solverCtx.assertGroundExpr(cons)
    eqState.setArena(newArena).setRex(resultCell)
  }

  private def decorateWithFailure(found: TlaEx, set: ArenaCell, setElems: Seq[ArenaCell],
                                   result: ArenaCell, failure: ArenaCell): TlaEx = {
    def mkNotIn(domElem: ArenaCell): TlaEx = {
      tla.not(tla.in(domElem, set))
    }

    val setEmptyInRuntime = tla.and(setElems.map(mkNotIn): _*)
    val eqFailure = tla.eql(result, failure)
    if (setElems.isEmpty) {
      eqFailure // statically flag a failure
    } else {
      tla.or(found, tla.and(eqFailure, setEmptyInRuntime))
    }
  }

  private def pickSet(cellType: CellT, set: ArenaCell, state: SymbState): SymbState = {
    var arena = state.arena.appendCell(cellType)
    val resultCell = arena.topCell
    arena = arena.appendCell(cellType)
    val auxCell = arena.topCell
    val elems = arena.getHas(set)
    // get all the cells pointed by the elements of the set
    val union = elems.map(e => Set(arena.getHas(e): _*))
      .fold(Set[ArenaCell]())(_ union _)

    // the resulting cell points to all the cells in the union
    arena = union.foldLeft(arena)((a, e) => a.appendHas(resultCell, e))

    // the auxillary cell equals to an element in the original set
    def mkIn(setElem: ArenaCell): TlaEx = {
      val inSet = tla.in(setElem, set)
      // here we don't use the deep equality, just the SMT equality
      val eq = tla.eql(setElem, auxCell)
      tla.and(inSet, eq)
    }

    def mkNotIn(setElem: ArenaCell): TlaEx = {
      tla.not(tla.in(setElem, set))
    }

    def inResultIffInAux(elem: ArenaCell): Unit = {
      val inResult = tla.in(elem, resultCell)
      val inAux = tla.in(elem, auxCell)
      state.solverCtx.assertGroundExpr(tla.equiv(inResult, inAux))
    }

    union.foreach(inResultIffInAux)
    val found = tla.or(elems.map(mkIn): _*)
    val cons = decorateWithFailure(found, set, elems, resultCell, arena.cellFailure())
    state.solverCtx.assertGroundExpr(cons)
    state.setArena(arena).setRex(resultCell)
  }

  // implements SE-PICK-FUN
  private def pickFun(cellType: CellT, funSet: ArenaCell, state: SymbState): SymbState = {
    var arena = funMerge(state.arena, funSet) // introduce DOM and CDM, see SE-PICK-FUN
    val dom = arena.getDom(funSet)
    val cdm = arena.getCdm(funSet)
    arena = arena.appendCell(cellType)
    val funCell = arena.topCell
    arena = arena.setDom(funCell, dom).setCdm(funCell, cdm)
    // associate a function constant with the function cell
    val _ = arena.solverContext.getOrIntroCellFun(funCell)
    // push the constraints to SMT
    val domElems = arena.getHas(dom)

    def resultEqFun(fun_i: ArenaCell): TlaEx = {
      val dom_i = arena.getDom(fun_i) // dom_i, i.e., the domain of f_{c_i}
      def inDom(c_j: ArenaCell): TlaEx = {
        // c_j \in dom <=> c_j \in DOMAIN(fun_i)
        tla.equiv(tla.in(c_j, dom), tla.in(c_j, dom_i))
      }
      def funAppEq(c_j: ArenaCell): TlaEx = {
        // c_j \in dom => f_new[c_j] = f_{fun_i}[c_j]
        tla.impl(tla.in(c_j, dom),
            tla.eql(tla.appFun(funCell, c_j),
                    tla.appFun(fun_i, c_j)))
      }
      // in(c_i, c_set) /\ f_new[c'_j] = f_{c_1}[c'_j] /\ ... /\ f_new[c'_j] = f_{c_i}[c'_j]
      val inDomAndFunAppEq = domElems.map(funAppEq) ++ domElems.map(inDom)
      tla.and(tla.in(fun_i, funSet) +: inDomAndFunAppEq: _*)
    }

    val funSetElems = arena.getHas(funSet)
    val existsFun = tla.or(funSetElems.map(resultEqFun): _*)
    val cons = decorateWithFailure(existsFun, funSet, funSetElems, funCell, arena.cellFailure())
    state.solverCtx.assertGroundExpr(existsFun)
    state.setArena(arena).setRex(funCell)
  }

  private def funMerge(arena: Arena, funSetCell: ArenaCell): Arena = {
    if (arena.hasDom(funSetCell) && arena.hasCdm(funSetCell)) {
      arena
    } else {
      val (argType: CellT, resultType: CellT) = funSetCell.cellType match {
        case FinSetT(FunT(FinSetT(at), rt)) =>
          (at, rt)

        case _ =>
          throw new RewriterException("Unexpected type for a set of functions: " + funSetCell.cellType)
      }

      val (newArena: Arena, cells: Seq[ArenaCell]) = arena.appendCellSeq(FinSetT(argType), FinSetT(resultType))
      val dom = cells.head
      val cdm = cells.tail.head
      val domUnion = arena.getHas(funSetCell).map(e => Set(arena.getHas(arena.getDom(e)): _*))
        .fold(Set[ArenaCell]())(_ union _)
      val cdmUnion = arena.getHas(funSetCell).map(e => Set(arena.getHas(arena.getCdm(e)): _*))
        .fold(Set[ArenaCell]())(_ union _)
      val newArena2 = domUnion.foldLeft(newArena)((a, e) => a.appendHas(dom, e))
      val newArena3 = cdmUnion.foldLeft(newArena2)((a, e) => a.appendHas(cdm, e))
      newArena3.setDom(funSetCell, dom).setCdm(funSetCell, cdm)
    }
  }
}
